// generated by protoc-gen-gotemplate. DO NOT EDIT.
// source: demo/service.proto 

export interface EchoRequest {
  
  message: string; 
}

export interface EchoResponse {
  
  message: string; 
}


/** 
 * DemoService shows a very simple service with only
 *  an Echo method.
 */
export interface DemoService {
  
/** 
 * Echo responds with the message passed into the
 *  request. Useful for testing and
 * as a minimal
 *  example.
 */
  Echo(req: EchoRequest): Promise<EchoResponse>
}

export function serveDemoService(service: DemoService) {
  async function handle(req: IncomingMessage): Promise<any> {
    switch (req.url) {
      case "/twirp/demo.DemoService/Echo":
        const res = service.Echo((await json(req)) as EchoRequest);
        if (!res) {
          throw new TwirpError(
            ErrorCode.Internal,
            "received an empty EchoResponse while calling Echo. empty responses are not supported"
          );
        }
        return res;
      default:
        throw new TwirpError(
          ErrorCode.BadRoute,
          "no handler for path " + req.url
        ).withMeta("twirp_invalid_route", req.method + " " + req.url);
    }
  }
  return responder(handle);
}



function responder(handle: (req: IncomingMessage) => Promise<any>) {
  return async (req: IncomingMessage, res: ServerResponse) => {
    let response;
    let status = 0;
    try {
      response = await handle(req);
      status = 200;
    } catch (err) {
      if (!(err instanceof TwirpError)) {
        err = new TwirpError(ErrorCode.Internal, err.message);
      }
      status = httpStatusFromErrorCode(err);
      response = err.toJSON();
    } finally {
      const body = JSON.stringify(response);
      res.writeHead(status, {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(body)
      });
      res.end(body);
    }
  };
}

async function json(req: IncomingMessage): Promise<any> {
  return new Promise((resolve, reject) => {
    let body: Uint8Array[] = [];
    req.on("data", onData);
    req.on("aborted", onAbort);
    req.on("close", close);
    req.on("error", onEnd);
    req.on("end", onEnd);

    function onData(chunk: Uint8Array) {
      body.push(chunk);
    }

    function onAbort() {
      onEnd(new TwirpError(ErrorCode.Aborted, "request aborted"));
    }

    function onEnd(err?: Error) {
      clean();
      if (err) {
        reject(err);
      } else {
        let output;
        try {
          output = JSON.parse(Buffer.concat(body).toString());
        } catch (err) {
          reject(
            new TwirpError(ErrorCode.Internal, "failed to read request body")
          );
        }
        resolve(output)
      }
    }

    function clean() {
      body = [];
      req.off("data", onData);
      req.off("aborted", onAbort);
      req.off("close", close);
      req.off("error", onEnd);
      req.off("end", onEnd);
    }
  });
}

enum ErrorCode {
  // Canceled indicates the operation was cancelled (typically by the caller).
  Canceled = "canceled",

  // Unknown error. For example when handling errors raised by APIs that do not
  // return enough error information.
  Unknown = "unknown",

  // InvalidArgument indicates client specified an invalid argument. It
  // indicates arguments that are problematic regardless of the state of the
  // system (i.e. a malformed file name, required argument, number out of range,
  // etc.).
  InvalidArgument = "invalid_argument",

  // Malformed indicates an error occurred while decoding the client's request.
  // This may mean that the message was encoded improperly, or that there is a
  // disagreement in message format between the client and server.
  Malformed = "malformed",

  // DeadlineExceeded means operation expired before completion. For operations
  // that change the state of the system, this error may be returned even if the
  // operation has completed successfully (timeout).
  DeadlineExceeded = "deadline_exceeded",

  // NotFound means some requested entity was not found.
  NotFound = "not_found",

  // BadRoute means that the requested URL path wasn't routable to a Twirp
  // service and method. This is returned by the generated server, and usually
  // shouldn't be returned by applications. Instead, applications should use
  // NotFound or Unimplemented.
  BadRoute = "bad_route",

  // AlreadyExists means an attempt to create an entity failed because one
  // already exists.
  AlreadyExists = "already_exists",

  // PermissionDenied indicates the caller does not have permission to execute
  // the specified operation. It must not be used if the caller cannot be
  // identified (Unauthenticated).
  PermissionDenied = "permission_denied",

  // Unauthenticated indicates the request does not have valid authentication
  // credentials for the operation.
  Unauthenticated = "unauthenticated",

  // ResourceExhausted indicates some resource has been exhausted, perhaps a
  // per-user quota, or perhaps the entire file system is out of space.
  ResourceExhausted = "resource_exhausted",

  // FailedPrecondition indicates operation was rejected because the system is
  // not in a state required for the operation's execution. For example, doing
  // an rmdir operation on a directory that is non-empty, or on a non-directory
  // object, or when having conflicting read-modify-write on the same resource.
  FailedPrecondition = "failed_precondition",

  // Aborted indicates the operation was aborted, typically due to a concurrency
  // issue like sequencer check failures, transaction aborts, etc.
  Aborted = "aborted",

  // OutOfRange means operation was attempted past the valid range. For example,
  // seeking or reading past end of a paginated collection.
  //
  // Unlike InvalidArgument, this error indicates a problem that may be fixed if
  // the system state changes (i.e. adding more items to the collection).
  //
  // There is a fair bit of overlap between FailedPrecondition and OutOfRange.
  // We recommend using OutOfRange (the more specific error) when it applies so
  // that callers who are iterating through a space can easily look for an
  // OutOfRange error to detect when they are done.
  OutOfRange = "out_of_range",

  // Unimplemented indicates operation is not implemented or not
  // supported/enabled in this service.
  Unimplemented = "unimplemented",

  // Internal errors. When some invariants expected by the underlying system
  // have been broken. In other words, something bad happened in the library or
  // backend service. Do not confuse with HTTP Internal Server Error; an
  // Internal error could also happen on the client code, i.e. when parsing a
  // server response.
  Internal = "internal",

  // Unavailable indicates the service is currently unavailable. This is a most
  // likely a transient condition and may be corrected by retrying with a
  // backoff.
  Unavailable = "unavailable",

  // DataLoss indicates unrecoverable data loss or corruption.
  DataLoss = "data_loss",

  // NoError is the zero-value, is considered an empty error and should not be
  // used.
  NoError = ""
}

class TwirpError extends Error {
  code: ErrorCode;
  meta: { [k: string]: string } | undefined;

  constructor(code: ErrorCode, msg: string) {
    super(msg);
    this.code = code;
  }

  withMeta(key: string, val: string): TwirpError {
    if (!this.meta) {
      this.meta = {};
    }
    this.meta[key] = val;
    return this;
  }

  toJSON() {
    const obj = {
      msg: this.message.slice(0, 1e6),
      code: this.code.toString(),
      meta: this.meta
    };
    if (!this.meta) {
      delete obj.meta;
    }
    return obj;
  }
}

export function httpStatusFromErrorCode(code: ErrorCode) {
  switch (code) {
    case ErrorCode.Canceled:
      return 408; // RequestTimeout
    case ErrorCode.Unknown:
      return 500; // Internal Server Error
    case ErrorCode.InvalidArgument:
      return 400; // BadRequest
    case ErrorCode.Malformed:
      return 400; // BadRequest
    case ErrorCode.DeadlineExceeded:
      return 408; // RequestTimeout
    case ErrorCode.NotFound:
      return 404; // Not Found
    case ErrorCode.BadRoute:
      return 404; // Not Found
    case ErrorCode.AlreadyExists:
      return 409; // Conflict
    case ErrorCode.PermissionDenied:
      return 403; // Forbidden
    case ErrorCode.Unauthenticated:
      return 401; // Unauthorized
    case ErrorCode.ResourceExhausted:
      return 403; // Forbidden
    case ErrorCode.FailedPrecondition:
      return 412; // Precondition Failed
    case ErrorCode.Aborted:
      return 409; // Conflict
    case ErrorCode.OutOfRange:
      return 400; // Bad Request
    case ErrorCode.Unimplemented:
      return 501; // Not Implemented
    case ErrorCode.Internal:
      return 500; // Internal Server Error
    case ErrorCode.Unavailable:
      return 503; // Service Unavailable
    case ErrorCode.DataLoss:
      return 500; // Internal Server Error
    case ErrorCode.NoError:
      return 200; // OK
    default:
      return 0; // Invalid!
  }
}
